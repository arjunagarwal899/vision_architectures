# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/schedulers/02_noise.ipynb.

# %% auto 0
__all__ = ['NoiseScheduler', 'LinearNoiseScheduler', 'CosineNoiseScheduler', 'SigmoidNoiseScheduler', 'FibonacciNoiseScheduler',
           'ExponentialNoiseScheduler', 'SquareRootNoiseScheduler']

# %% ../../nbs/schedulers/02_noise.ipynb 2
import torch
from torch import nn

# %% ../../nbs/schedulers/02_noise.ipynb 4
class NoiseScheduler(nn.Module):
    """Base class for Gussian noise schedulers used in diffusion models"""

    def __init__(self, betas: torch.Tensor | None = None, alphas_cumprod: torch.Tensor | None = None):
        super().__init__()

        assert (betas is None) != (alphas_cumprod is None), "Either betas or alphas_cumprod should be provided"

        if betas is not None:
            alphas = 1.0 - betas
            alphas_cumprod = torch.cumprod(alphas, dim=0)
            sqrt_alphas_cumprod = torch.sqrt(alphas_cumprod)
            sqrt_one_minus_alphas_cumprod = torch.sqrt(1.0 - alphas_cumprod)
        elif alphas_cumprod is not None:
            alphas = torch.cat([alphas_cumprod[0:1], alphas_cumprod[1:] / alphas_cumprod[:-1]], dim=0)
            betas = 1.0 - alphas
            sqrt_alphas_cumprod = torch.sqrt(alphas_cumprod)
            sqrt_one_minus_alphas_cumprod = torch.sqrt(1.0 - alphas_cumprod)
        else:
            raise NotImplementedError

        self.T = len(betas)

        # For t=0 cases:
        betas = torch.cat([torch.tensor([0.0]), betas])
        alphas = torch.cat([torch.tensor([1.0]), alphas])
        alphas_cumprod = torch.cat([torch.tensor([1.0]), alphas_cumprod])
        sqrt_alphas_cumprod = torch.cat([torch.tensor([1.0]), sqrt_alphas_cumprod])
        sqrt_one_minus_alphas_cumprod = torch.cat([torch.tensor([0.0]), sqrt_one_minus_alphas_cumprod])

        # Register as non-persistent buffers so that they are moved to the correct device
        self.register_buffer("betas", betas, persistent=False)
        self.register_buffer("alphas", alphas, persistent=False)
        self.register_buffer("alphas_cumprod", alphas_cumprod, persistent=False)
        self.register_buffer("sqrt_alphas_cumprod", sqrt_alphas_cumprod, persistent=False)
        self.register_buffer("sqrt_one_minus_alphas_cumprod", sqrt_one_minus_alphas_cumprod, persistent=False)

    def add_noise(self, x0: torch.Tensor, t: torch.Tensor, noise: torch.Tensor | None = None):
        """If noise is not provided, it is sampled from a standard normal distribution"""

        # x0: (b, ...)
        # t: (b,)
        # noise: (b, ...)

        self._validate_timesteps(t)

        noise_provided: bool = True
        if noise is None:
            noise_provided = False
            noise = torch.randn_like(x0)

        unsqueeze = tuple([slice(0, None)] + [None] * (len(x0.shape) - 1))
        xt = self.sqrt_alphas_cumprod[t][unsqueeze] * x0 + self.sqrt_one_minus_alphas_cumprod[t][unsqueeze] * noise

        if not noise_provided:
            return xt, noise
        return xt

    def remove_noise(self, xt: torch.Tensor, noise_pred: torch.Tensor, t: torch.Tensor, eta: float = 1.0):
        """Removes noise from the input tensor xt using the predicted noise and the time step t.
        Equation 12 from the `DDIM paper <https://arxiv.org/pdf/2010.02502>`__.

        Args:
            xt: The input tensor with noise.
            noise_pred: The predicted noise tensor.
            t: The time step tensor.
            eta: The eta parameter for DDIM sampling. Setting it to 1.0 is equivalent to DDPM sampling, while
                setting it to 0.0 is equivalent to DDIM sampling. Use values in between for an interpolation between
                the two.

        Returns:
            x0_hat: The estimated clean image tensor.
            xt_minus_1_hat: The estimated previous noisy image tensor.
        """
        # xt: (b, ...)
        # noise_pred: (b, ...)
        # t: (b,)

        self._validate_timesteps(t)
        assert 0 <= eta <= 1, "ddim_eta should be between [0, 1]"

        # Slice values to get the correct shape of all required buffers
        unsqueeze = tuple([slice(0, None)] + [None] * (len(xt.shape) - 1))

        # Estimate x0
        x0_hat = (xt - (self.sqrt_one_minus_alphas_cumprod[t][unsqueeze] * noise_pred)) / self.sqrt_alphas_cumprod[t][
            unsqueeze
        ]

        # Start building x{t-1}
        mean_t = self.sqrt_alphas_cumprod[t - 1][unsqueeze] * x0_hat

        variance_t = (
            eta**2
            * self.betas[t][unsqueeze]
            * (1.0 - self.alphas_cumprod[t - 1][unsqueeze])
            / (1.0 - self.alphas_cumprod[t][unsqueeze])
        )
        sigma_t = torch.sqrt(variance_t)

        direction_t = torch.sqrt(1.0 - self.alphas_cumprod[t - 1][unsqueeze] - variance_t) * noise_pred

        xt_minus_1_hat = mean_t + direction_t

        if eta > 0.0:  # Don't waste GPU memory if not required
            standard_noise = torch.randn_like(xt)
            xt_minus_1_hat = xt_minus_1_hat + sigma_t * standard_noise

        return x0_hat, xt_minus_1_hat

    def get_velocity(self, x0: torch.Tensor, t: torch.Tensor, noise: torch.Tensor):
        """Computes the velocity of the diffusion process at time step t.

        Args:
            x0: The input tensor (clean image).
            t: The time step tensor.
            noise: The noise tensor.

        Returns:
            velocity: The estimated velocity tensor.
        """
        # x0: (b, ...)
        # t: (b,)
        # noise: (b, ...)

        self._validate_timesteps(t)

        unsqueeze = tuple([slice(0, None)] + [None] * (len(x0.shape) - 1))

        # Estimate velocity
        velocity = (
            self.sqrt_alphas_cumprod[t][unsqueeze] * noise - self.sqrt_one_minus_alphas_cumprod[t][unsqueeze] * x0
        )

        return velocity

    def _validate_timesteps(self, timesteps: torch.Tensor, allow_zero: bool = False):
        """Validates the timesteps tensor to ensure it is within the valid range."""

        upper_bound = self.T
        lower_bound = 0 if allow_zero else 1
        if not (lower_bound <= timesteps).all() or not (timesteps <= upper_bound).all():
            raise ValueError(f"Timesteps should be between [{lower_bound}, {upper_bound}]")

# %% ../../nbs/schedulers/02_noise.ipynb 6
class LinearNoiseScheduler(NoiseScheduler):
    # https://arxiv.org/pdf/2006.11239
    def __init__(self, T: int, min_beta: float = 0.0001, max_beta: float = 0.02):
        betas = torch.linspace(min_beta, max_beta, T)
        super().__init__(betas)

# %% ../../nbs/schedulers/02_noise.ipynb 8
class CosineNoiseScheduler(NoiseScheduler):
    # https://arxiv.org/pdf/2102.09672
    def __init__(self, T: int, s: float = 0.008, min_alphas_cumprod: float = 1e-9):
        self.s = s

        alphas_cumprod = torch.cos(((torch.arange(T) / T + s) / (1 + s)) * (torch.pi / 2)) ** 2
        alphas_cumprod = alphas_cumprod / alphas_cumprod[0]
        alphas_cumprod.clamp_(min=min_alphas_cumprod)
        super().__init__(alphas_cumprod=alphas_cumprod)

# %% ../../nbs/schedulers/02_noise.ipynb 10
class SigmoidNoiseScheduler(NoiseScheduler):
    # https://arxiv.org/pdf/2212.11972
    def __init__(
        self, T: int, tau: float = 1.0, sigmoid_start: int = -3, sigmoid_end: int = 3, min_alphas_cumprod: float = 1e-9
    ):
        self.tau = tau
        self.sigmoid_start = sigmoid_start
        self.sigmoid_end = sigmoid_end

        start = torch.tensor(sigmoid_start)
        end = torch.tensor(sigmoid_end)
        v_start = torch.sigmoid(start / tau)
        v_end = torch.sigmoid(end / tau)

        alphas_cumprod = (-torch.sigmoid(((torch.arange(T) / T) * (end - start) + start) / tau) + v_end) / (
            v_end - v_start
        )
        alphas_cumprod.clamp_(min=min_alphas_cumprod)
        super().__init__(alphas_cumprod=alphas_cumprod)

# %% ../../nbs/schedulers/02_noise.ipynb 12
class FibonacciNoiseScheduler(NoiseScheduler):
    # https://arxiv.org/pdf/2009.00713
    def __init__(self, T: int, first_element: float = 1e-6, second_element: float = 2e-6):
        assert T > 2, "T should be greater than 2"
        if T > 25:
            print("Warning: This noise scheduler explodes very quickly. Be careful with large T values.")
        betas = [first_element, second_element]
        for _ in range(2, T):
            betas.append(betas[-1] + betas[-2])
        betas = torch.Tensor(betas).clamp(0.0, 1.0)
        super().__init__(betas=betas)

# %% ../../nbs/schedulers/02_noise.ipynb 14
class ExponentialNoiseScheduler(NoiseScheduler):
    def __init__(self, T: int, beta_min: float = 0.0001, beta_max: float = 0.02):
        self.beta_min = beta_min
        self.beta_max = beta_max

        betas = beta_min * (beta_max / beta_min) ** ((torch.arange(T) - 1) / (T - 1))
        super().__init__(betas=betas)

# %% ../../nbs/schedulers/02_noise.ipynb 16
class SquareRootNoiseScheduler(NoiseScheduler):
    # https://arxiv.org/pdf/2205.14217
    def __init__(self, T: int, s: float = 0.008, min_alphas_cumprod: float = 1e-9):
        self.s = s

        alphas_cumprod = 1 - torch.sqrt(torch.arange(T) / T + s)
        alphas_cumprod.clamp_(min=min_alphas_cumprod)
        super().__init__(alphas_cumprod=alphas_cumprod)
