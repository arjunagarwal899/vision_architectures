# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/schedulers/03_cyclic.ipynb.

# %% auto 0
__all__ = ['SineScheduler', 'SineLR']

# %% ../../nbs/schedulers/03_cyclic.ipynb 2
import math

from torch.optim.lr_scheduler import LRScheduler

# %% ../../nbs/schedulers/03_cyclic.ipynb 5
class SineScheduler:
    def __init__(self, start_value: float, max_value: float, decay: float = 0.0, wavelength: int | None = None):
        assert 0.0 <= decay < 1.0, "Decay must be between 0 and 1"

        self.start_value = start_value
        self.max_value = max_value
        self.decay_factor = 1 - decay
        self.wavelength = None

        self.pseudo_max_value = max_value / (self.decay_factor**0.5)

        self.x = 1

        if wavelength is not None:
            self.set_wavelength(wavelength)

    def set_wavelength(self, wavelength: int):
        assert wavelength > 0, "Wavelength must be greater than 0"
        self.wavelength = wavelength
        return self  # to allow chaining

    def is_ready(self):
        return self.wavelength is not None

    def get(self):
        if not self.is_ready():
            raise ValueError("Call set_wavelength first")

        # Calculate angle based on current step and wavelength and get sine value
        angle = (-0.5 + 2 * self.x / self.wavelength) * math.pi
        sine = math.sin(angle)

        # Scale it to the range of pseudo_max_lr and max_lr
        scaled = (self.pseudo_max_value - self.start_value) * (1 + sine) / 2

        # Apply decay to it
        decayed = scaled * self.decay_factor ** ((self.x + 1) / self.wavelength)

        # Increase it by the start_lr
        lr = decayed + self.start_value

        return lr

    def step(self):
        if not self.is_ready():
            raise ValueError("Call set_wavelength first")
        self.x = self.x + 1

# %% ../../nbs/schedulers/03_cyclic.ipynb 8
class SineLR(LRScheduler):
    def __init__(self, optimizer, start_lr, max_lr, wavelength, decay, last_epoch=-1, verbose="deprecated"):
        self.scheduler = SineScheduler(start_lr, max_lr, decay).set_wavelength(wavelength)
        self.scheduler.x -= 1  # To match the output of the non-LR scheduler
        super().__init__(optimizer, last_epoch, verbose)

    def get_lr(self):
        lr = self.scheduler.get()
        return [lr for _ in self.optimizer.param_groups]

    def step(self, epoch=None):
        self.scheduler.step()
        return super().step(epoch)
